//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha2

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Activedirectory) DeepCopyInto(out *Activedirectory) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Activedirectory.
func (in *Activedirectory) DeepCopy() *Activedirectory {
	if in == nil {
		return nil
	}
	out := new(Activedirectory)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Activedirectory) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ActivedirectoryList) DeepCopyInto(out *ActivedirectoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Activedirectory, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ActivedirectoryList.
func (in *ActivedirectoryList) DeepCopy() *ActivedirectoryList {
	if in == nil {
		return nil
	}
	out := new(ActivedirectoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ActivedirectoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ActivedirectoryObservation) DeepCopyInto(out *ActivedirectoryObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ActivedirectoryObservation.
func (in *ActivedirectoryObservation) DeepCopy() *ActivedirectoryObservation {
	if in == nil {
		return nil
	}
	out := new(ActivedirectoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ActivedirectoryParameters) DeepCopyInto(out *ActivedirectoryParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CertificateSecretRef != nil {
		in, out := &in.CertificateSecretRef, &out.CertificateSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ConnectionTimeout != nil {
		in, out := &in.ConnectionTimeout, &out.ConnectionTimeout
		*out = new(float64)
		**out = **in
	}
	if in.DefaultLoginDomain != nil {
		in, out := &in.DefaultLoginDomain, &out.DefaultLoginDomain
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupDnAttribute != nil {
		in, out := &in.GroupDnAttribute, &out.GroupDnAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberMappingAttribute != nil {
		in, out := &in.GroupMemberMappingAttribute, &out.GroupMemberMappingAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberUserAttribute != nil {
		in, out := &in.GroupMemberUserAttribute, &out.GroupMemberUserAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupNameAttribute != nil {
		in, out := &in.GroupNameAttribute, &out.GroupNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupObjectClass != nil {
		in, out := &in.GroupObjectClass, &out.GroupObjectClass
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchAttribute != nil {
		in, out := &in.GroupSearchAttribute, &out.GroupSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchBase != nil {
		in, out := &in.GroupSearchBase, &out.GroupSearchBase
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchFilter != nil {
		in, out := &in.GroupSearchFilter, &out.GroupSearchFilter
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.NestedGroupMembershipEnabled != nil {
		in, out := &in.NestedGroupMembershipEnabled, &out.NestedGroupMembershipEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Servers != nil {
		in, out := &in.Servers, &out.Servers
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	out.ServiceAccountPasswordSecretRef = in.ServiceAccountPasswordSecretRef
	out.ServiceAccountUsernameSecretRef = in.ServiceAccountUsernameSecretRef
	if in.StartTLS != nil {
		in, out := &in.StartTLS, &out.StartTLS
		*out = new(bool)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	out.TestPasswordSecretRef = in.TestPasswordSecretRef
	if in.TestUsername != nil {
		in, out := &in.TestUsername, &out.TestUsername
		*out = new(string)
		**out = **in
	}
	if in.UserDisabledBitMask != nil {
		in, out := &in.UserDisabledBitMask, &out.UserDisabledBitMask
		*out = new(float64)
		**out = **in
	}
	if in.UserEnabledAttribute != nil {
		in, out := &in.UserEnabledAttribute, &out.UserEnabledAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserLoginAttribute != nil {
		in, out := &in.UserLoginAttribute, &out.UserLoginAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserNameAttribute != nil {
		in, out := &in.UserNameAttribute, &out.UserNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserObjectClass != nil {
		in, out := &in.UserObjectClass, &out.UserObjectClass
		*out = new(string)
		**out = **in
	}
	if in.UserSearchAttribute != nil {
		in, out := &in.UserSearchAttribute, &out.UserSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserSearchBase != nil {
		in, out := &in.UserSearchBase, &out.UserSearchBase
		*out = new(string)
		**out = **in
	}
	if in.UserSearchFilter != nil {
		in, out := &in.UserSearchFilter, &out.UserSearchFilter
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ActivedirectoryParameters.
func (in *ActivedirectoryParameters) DeepCopy() *ActivedirectoryParameters {
	if in == nil {
		return nil
	}
	out := new(ActivedirectoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ActivedirectorySpec) DeepCopyInto(out *ActivedirectorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ActivedirectorySpec.
func (in *ActivedirectorySpec) DeepCopy() *ActivedirectorySpec {
	if in == nil {
		return nil
	}
	out := new(ActivedirectorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ActivedirectoryStatus) DeepCopyInto(out *ActivedirectoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ActivedirectoryStatus.
func (in *ActivedirectoryStatus) DeepCopy() *ActivedirectoryStatus {
	if in == nil {
		return nil
	}
	out := new(ActivedirectoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Adfs) DeepCopyInto(out *Adfs) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Adfs.
func (in *Adfs) DeepCopy() *Adfs {
	if in == nil {
		return nil
	}
	out := new(Adfs)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Adfs) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AdfsList) DeepCopyInto(out *AdfsList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Adfs, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AdfsList.
func (in *AdfsList) DeepCopy() *AdfsList {
	if in == nil {
		return nil
	}
	out := new(AdfsList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AdfsList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AdfsObservation) DeepCopyInto(out *AdfsObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AdfsObservation.
func (in *AdfsObservation) DeepCopy() *AdfsObservation {
	if in == nil {
		return nil
	}
	out := new(AdfsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AdfsParameters) DeepCopyInto(out *AdfsParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	out.IdpMetadataContentSecretRef = in.IdpMetadataContentSecretRef
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	out.SpCertSecretRef = in.SpCertSecretRef
	out.SpKeySecretRef = in.SpKeySecretRef
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AdfsParameters.
func (in *AdfsParameters) DeepCopy() *AdfsParameters {
	if in == nil {
		return nil
	}
	out := new(AdfsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AdfsSpec) DeepCopyInto(out *AdfsSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AdfsSpec.
func (in *AdfsSpec) DeepCopy() *AdfsSpec {
	if in == nil {
		return nil
	}
	out := new(AdfsSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AdfsStatus) DeepCopyInto(out *AdfsStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AdfsStatus.
func (in *AdfsStatus) DeepCopy() *AdfsStatus {
	if in == nil {
		return nil
	}
	out := new(AdfsStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Azuread) DeepCopyInto(out *Azuread) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Azuread.
func (in *Azuread) DeepCopy() *Azuread {
	if in == nil {
		return nil
	}
	out := new(Azuread)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Azuread) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureadList) DeepCopyInto(out *AzureadList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Azuread, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureadList.
func (in *AzureadList) DeepCopy() *AzureadList {
	if in == nil {
		return nil
	}
	out := new(AzureadList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureadList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureadObservation) DeepCopyInto(out *AzureadObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureadObservation.
func (in *AzureadObservation) DeepCopy() *AzureadObservation {
	if in == nil {
		return nil
	}
	out := new(AzureadObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureadParameters) DeepCopyInto(out *AzureadParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	out.ApplicationIDSecretRef = in.ApplicationIDSecretRef
	out.ApplicationSecretSecretRef = in.ApplicationSecretSecretRef
	if in.AuthEndpoint != nil {
		in, out := &in.AuthEndpoint, &out.AuthEndpoint
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Endpoint != nil {
		in, out := &in.Endpoint, &out.Endpoint
		*out = new(string)
		**out = **in
	}
	if in.GraphEndpoint != nil {
		in, out := &in.GraphEndpoint, &out.GraphEndpoint
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherURL != nil {
		in, out := &in.RancherURL, &out.RancherURL
		*out = new(string)
		**out = **in
	}
	if in.TenantID != nil {
		in, out := &in.TenantID, &out.TenantID
		*out = new(string)
		**out = **in
	}
	if in.TokenEndpoint != nil {
		in, out := &in.TokenEndpoint, &out.TokenEndpoint
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureadParameters.
func (in *AzureadParameters) DeepCopy() *AzureadParameters {
	if in == nil {
		return nil
	}
	out := new(AzureadParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureadSpec) DeepCopyInto(out *AzureadSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureadSpec.
func (in *AzureadSpec) DeepCopy() *AzureadSpec {
	if in == nil {
		return nil
	}
	out := new(AzureadSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureadStatus) DeepCopyInto(out *AzureadStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureadStatus.
func (in *AzureadStatus) DeepCopy() *AzureadStatus {
	if in == nil {
		return nil
	}
	out := new(AzureadStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Freeipa) DeepCopyInto(out *Freeipa) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Freeipa.
func (in *Freeipa) DeepCopy() *Freeipa {
	if in == nil {
		return nil
	}
	out := new(Freeipa)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Freeipa) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FreeipaList) DeepCopyInto(out *FreeipaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Freeipa, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FreeipaList.
func (in *FreeipaList) DeepCopy() *FreeipaList {
	if in == nil {
		return nil
	}
	out := new(FreeipaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *FreeipaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FreeipaObservation) DeepCopyInto(out *FreeipaObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FreeipaObservation.
func (in *FreeipaObservation) DeepCopy() *FreeipaObservation {
	if in == nil {
		return nil
	}
	out := new(FreeipaObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FreeipaParameters) DeepCopyInto(out *FreeipaParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CertificateSecretRef != nil {
		in, out := &in.CertificateSecretRef, &out.CertificateSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ConnectionTimeout != nil {
		in, out := &in.ConnectionTimeout, &out.ConnectionTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupDnAttribute != nil {
		in, out := &in.GroupDnAttribute, &out.GroupDnAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberMappingAttribute != nil {
		in, out := &in.GroupMemberMappingAttribute, &out.GroupMemberMappingAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberUserAttribute != nil {
		in, out := &in.GroupMemberUserAttribute, &out.GroupMemberUserAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupNameAttribute != nil {
		in, out := &in.GroupNameAttribute, &out.GroupNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupObjectClass != nil {
		in, out := &in.GroupObjectClass, &out.GroupObjectClass
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchAttribute != nil {
		in, out := &in.GroupSearchAttribute, &out.GroupSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchBase != nil {
		in, out := &in.GroupSearchBase, &out.GroupSearchBase
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.NestedGroupMembershipEnabled != nil {
		in, out := &in.NestedGroupMembershipEnabled, &out.NestedGroupMembershipEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Servers != nil {
		in, out := &in.Servers, &out.Servers
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	out.ServiceAccountDistinguishedNameSecretRef = in.ServiceAccountDistinguishedNameSecretRef
	out.ServiceAccountPasswordSecretRef = in.ServiceAccountPasswordSecretRef
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	out.TestPasswordSecretRef = in.TestPasswordSecretRef
	if in.TestUsername != nil {
		in, out := &in.TestUsername, &out.TestUsername
		*out = new(string)
		**out = **in
	}
	if in.UserDisabledBitMask != nil {
		in, out := &in.UserDisabledBitMask, &out.UserDisabledBitMask
		*out = new(float64)
		**out = **in
	}
	if in.UserEnabledAttribute != nil {
		in, out := &in.UserEnabledAttribute, &out.UserEnabledAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserLoginAttribute != nil {
		in, out := &in.UserLoginAttribute, &out.UserLoginAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserMemberAttribute != nil {
		in, out := &in.UserMemberAttribute, &out.UserMemberAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserNameAttribute != nil {
		in, out := &in.UserNameAttribute, &out.UserNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserObjectClass != nil {
		in, out := &in.UserObjectClass, &out.UserObjectClass
		*out = new(string)
		**out = **in
	}
	if in.UserSearchAttribute != nil {
		in, out := &in.UserSearchAttribute, &out.UserSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserSearchBase != nil {
		in, out := &in.UserSearchBase, &out.UserSearchBase
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FreeipaParameters.
func (in *FreeipaParameters) DeepCopy() *FreeipaParameters {
	if in == nil {
		return nil
	}
	out := new(FreeipaParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FreeipaSpec) DeepCopyInto(out *FreeipaSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FreeipaSpec.
func (in *FreeipaSpec) DeepCopy() *FreeipaSpec {
	if in == nil {
		return nil
	}
	out := new(FreeipaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FreeipaStatus) DeepCopyInto(out *FreeipaStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FreeipaStatus.
func (in *FreeipaStatus) DeepCopy() *FreeipaStatus {
	if in == nil {
		return nil
	}
	out := new(FreeipaStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Github) DeepCopyInto(out *Github) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Github.
func (in *Github) DeepCopy() *Github {
	if in == nil {
		return nil
	}
	out := new(Github)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Github) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GithubList) DeepCopyInto(out *GithubList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Github, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GithubList.
func (in *GithubList) DeepCopy() *GithubList {
	if in == nil {
		return nil
	}
	out := new(GithubList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GithubList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GithubObservation) DeepCopyInto(out *GithubObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GithubObservation.
func (in *GithubObservation) DeepCopy() *GithubObservation {
	if in == nil {
		return nil
	}
	out := new(GithubObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GithubParameters) DeepCopyInto(out *GithubParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	out.ClientIDSecretRef = in.ClientIDSecretRef
	out.ClientSecretSecretRef = in.ClientSecretSecretRef
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Hostname != nil {
		in, out := &in.Hostname, &out.Hostname
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GithubParameters.
func (in *GithubParameters) DeepCopy() *GithubParameters {
	if in == nil {
		return nil
	}
	out := new(GithubParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GithubSpec) DeepCopyInto(out *GithubSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GithubSpec.
func (in *GithubSpec) DeepCopy() *GithubSpec {
	if in == nil {
		return nil
	}
	out := new(GithubSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GithubStatus) DeepCopyInto(out *GithubStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GithubStatus.
func (in *GithubStatus) DeepCopy() *GithubStatus {
	if in == nil {
		return nil
	}
	out := new(GithubStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Keycloak) DeepCopyInto(out *Keycloak) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Keycloak.
func (in *Keycloak) DeepCopy() *Keycloak {
	if in == nil {
		return nil
	}
	out := new(Keycloak)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Keycloak) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeycloakList) DeepCopyInto(out *KeycloakList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Keycloak, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeycloakList.
func (in *KeycloakList) DeepCopy() *KeycloakList {
	if in == nil {
		return nil
	}
	out := new(KeycloakList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KeycloakList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeycloakObservation) DeepCopyInto(out *KeycloakObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeycloakObservation.
func (in *KeycloakObservation) DeepCopy() *KeycloakObservation {
	if in == nil {
		return nil
	}
	out := new(KeycloakObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeycloakParameters) DeepCopyInto(out *KeycloakParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EntityID != nil {
		in, out := &in.EntityID, &out.EntityID
		*out = new(string)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	out.IdpMetadataContentSecretRef = in.IdpMetadataContentSecretRef
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	out.SpCertSecretRef = in.SpCertSecretRef
	out.SpKeySecretRef = in.SpKeySecretRef
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeycloakParameters.
func (in *KeycloakParameters) DeepCopy() *KeycloakParameters {
	if in == nil {
		return nil
	}
	out := new(KeycloakParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeycloakSpec) DeepCopyInto(out *KeycloakSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeycloakSpec.
func (in *KeycloakSpec) DeepCopy() *KeycloakSpec {
	if in == nil {
		return nil
	}
	out := new(KeycloakSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeycloakStatus) DeepCopyInto(out *KeycloakStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeycloakStatus.
func (in *KeycloakStatus) DeepCopy() *KeycloakStatus {
	if in == nil {
		return nil
	}
	out := new(KeycloakStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Okta) DeepCopyInto(out *Okta) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Okta.
func (in *Okta) DeepCopy() *Okta {
	if in == nil {
		return nil
	}
	out := new(Okta)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Okta) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OktaList) DeepCopyInto(out *OktaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Okta, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OktaList.
func (in *OktaList) DeepCopy() *OktaList {
	if in == nil {
		return nil
	}
	out := new(OktaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OktaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OktaObservation) DeepCopyInto(out *OktaObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OktaObservation.
func (in *OktaObservation) DeepCopy() *OktaObservation {
	if in == nil {
		return nil
	}
	out := new(OktaObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OktaParameters) DeepCopyInto(out *OktaParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	out.IdpMetadataContentSecretRef = in.IdpMetadataContentSecretRef
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	out.SpCertSecretRef = in.SpCertSecretRef
	out.SpKeySecretRef = in.SpKeySecretRef
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OktaParameters.
func (in *OktaParameters) DeepCopy() *OktaParameters {
	if in == nil {
		return nil
	}
	out := new(OktaParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OktaSpec) DeepCopyInto(out *OktaSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OktaSpec.
func (in *OktaSpec) DeepCopy() *OktaSpec {
	if in == nil {
		return nil
	}
	out := new(OktaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OktaStatus) DeepCopyInto(out *OktaStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OktaStatus.
func (in *OktaStatus) DeepCopy() *OktaStatus {
	if in == nil {
		return nil
	}
	out := new(OktaStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Openldap) DeepCopyInto(out *Openldap) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Openldap.
func (in *Openldap) DeepCopy() *Openldap {
	if in == nil {
		return nil
	}
	out := new(Openldap)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Openldap) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenldapList) DeepCopyInto(out *OpenldapList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Openldap, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenldapList.
func (in *OpenldapList) DeepCopy() *OpenldapList {
	if in == nil {
		return nil
	}
	out := new(OpenldapList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpenldapList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenldapObservation) DeepCopyInto(out *OpenldapObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenldapObservation.
func (in *OpenldapObservation) DeepCopy() *OpenldapObservation {
	if in == nil {
		return nil
	}
	out := new(OpenldapObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenldapParameters) DeepCopyInto(out *OpenldapParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CertificateSecretRef != nil {
		in, out := &in.CertificateSecretRef, &out.CertificateSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ConnectionTimeout != nil {
		in, out := &in.ConnectionTimeout, &out.ConnectionTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupDnAttribute != nil {
		in, out := &in.GroupDnAttribute, &out.GroupDnAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberMappingAttribute != nil {
		in, out := &in.GroupMemberMappingAttribute, &out.GroupMemberMappingAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberUserAttribute != nil {
		in, out := &in.GroupMemberUserAttribute, &out.GroupMemberUserAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupNameAttribute != nil {
		in, out := &in.GroupNameAttribute, &out.GroupNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupObjectClass != nil {
		in, out := &in.GroupObjectClass, &out.GroupObjectClass
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchAttribute != nil {
		in, out := &in.GroupSearchAttribute, &out.GroupSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchBase != nil {
		in, out := &in.GroupSearchBase, &out.GroupSearchBase
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.NestedGroupMembershipEnabled != nil {
		in, out := &in.NestedGroupMembershipEnabled, &out.NestedGroupMembershipEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Servers != nil {
		in, out := &in.Servers, &out.Servers
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	out.ServiceAccountDistinguishedNameSecretRef = in.ServiceAccountDistinguishedNameSecretRef
	out.ServiceAccountPasswordSecretRef = in.ServiceAccountPasswordSecretRef
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	out.TestPasswordSecretRef = in.TestPasswordSecretRef
	if in.TestUsername != nil {
		in, out := &in.TestUsername, &out.TestUsername
		*out = new(string)
		**out = **in
	}
	if in.UserDisabledBitMask != nil {
		in, out := &in.UserDisabledBitMask, &out.UserDisabledBitMask
		*out = new(float64)
		**out = **in
	}
	if in.UserEnabledAttribute != nil {
		in, out := &in.UserEnabledAttribute, &out.UserEnabledAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserLoginAttribute != nil {
		in, out := &in.UserLoginAttribute, &out.UserLoginAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserMemberAttribute != nil {
		in, out := &in.UserMemberAttribute, &out.UserMemberAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserNameAttribute != nil {
		in, out := &in.UserNameAttribute, &out.UserNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserObjectClass != nil {
		in, out := &in.UserObjectClass, &out.UserObjectClass
		*out = new(string)
		**out = **in
	}
	if in.UserSearchAttribute != nil {
		in, out := &in.UserSearchAttribute, &out.UserSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserSearchBase != nil {
		in, out := &in.UserSearchBase, &out.UserSearchBase
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenldapParameters.
func (in *OpenldapParameters) DeepCopy() *OpenldapParameters {
	if in == nil {
		return nil
	}
	out := new(OpenldapParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenldapSpec) DeepCopyInto(out *OpenldapSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenldapSpec.
func (in *OpenldapSpec) DeepCopy() *OpenldapSpec {
	if in == nil {
		return nil
	}
	out := new(OpenldapSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenldapStatus) DeepCopyInto(out *OpenldapStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenldapStatus.
func (in *OpenldapStatus) DeepCopy() *OpenldapStatus {
	if in == nil {
		return nil
	}
	out := new(OpenldapStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Ping) DeepCopyInto(out *Ping) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Ping.
func (in *Ping) DeepCopy() *Ping {
	if in == nil {
		return nil
	}
	out := new(Ping)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Ping) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PingList) DeepCopyInto(out *PingList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Ping, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PingList.
func (in *PingList) DeepCopy() *PingList {
	if in == nil {
		return nil
	}
	out := new(PingList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PingList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PingObservation) DeepCopyInto(out *PingObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PingObservation.
func (in *PingObservation) DeepCopy() *PingObservation {
	if in == nil {
		return nil
	}
	out := new(PingObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PingParameters) DeepCopyInto(out *PingParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	out.IdpMetadataContentSecretRef = in.IdpMetadataContentSecretRef
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	out.SpCertSecretRef = in.SpCertSecretRef
	out.SpKeySecretRef = in.SpKeySecretRef
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PingParameters.
func (in *PingParameters) DeepCopy() *PingParameters {
	if in == nil {
		return nil
	}
	out := new(PingParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PingSpec) DeepCopyInto(out *PingSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PingSpec.
func (in *PingSpec) DeepCopy() *PingSpec {
	if in == nil {
		return nil
	}
	out := new(PingSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PingStatus) DeepCopyInto(out *PingStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PingStatus.
func (in *PingStatus) DeepCopy() *PingStatus {
	if in == nil {
		return nil
	}
	out := new(PingStatus)
	in.DeepCopyInto(out)
	return out
}
